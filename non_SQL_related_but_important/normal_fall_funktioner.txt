Hotelldirektör:
    [D]Skicka erbjudanden via mejl ("skicka erbjudanden till tidigare kunder")
        - viz. hitta mejl addresser till kunder, med namn och dylikt
        - viz. hitta erbjudanden. 
    -- hitta vad som är relevant i kund.
    select mejl_address, fornamn, efternamn from kund;
    -- alla nutida och framtida erbjudanden.
    select * from erbjudande WHERE now() < slut;
    -- alla aktuella erbjudanden just nu.
    select * from erbjudande WHERE now() < slut AND now() > `start`;

    [D]Lägga in erbjudandens giltighetstid
        ** enkel
        - viz. update
    *** SQL::::
        update erbjudande 
        SET start = {startdatum}, slut = {startdatum}
        WHERE erbjudande_id = {X}
        ** EXAMPLE QUERY:
                update erbjudande 
                SET start = '2024-10-15 00:00:00', slut = '2024-11-15 23:59:59'
                WHERE erbjudande_id = 1
    

    Statistik på vilken typ av rum som är attraktiva en viss period
        - först definera perioden <- input
        - bokning: lista över incheckning som faller inom denna tidsram.
        -> ta fram rum därifrån.
        -> från rum hitta rumtyp, räkna  (count) antal av varje rumtyp. 



    [D]Se när det är middag bokad och för hur många personer 
        - SELECT X, y from middag. (order by date)
        ** EXAMPLE QUERY:
        SELECT datum, antal_personer, grupp_bokning_id FROM middag 
        ORDER BY datum;


    [D]Uppdatera hur många personer som ska äta
        ** enkel
        - update statement
        *** SQL::::
        update middag
        SET antal_personer = {X}
        WHERE middag_id = {Y}
        ** EXAMPLE QUERY:
        -- usecase example: en person har blivit sjuk och ska inte vara med på middagen men sova i rummet.
        update middag
        SET antal_personer = antal_personer - 1
        WHERE middag_id = 1


Receptionist:
    [D] Se lediga rum av en viss typ en viss tidsperiod, 
        viz. en kund vill boka ett enkelrum
        -> gå in i bokning, gå in och kolla all data, ta bort träffar där någon av dagarna
        inom tidsperioden har träff mellan ett derivade value som utgår ifrån:
            -> checkatin och checkatut ==> tabell med datum upptaget. 
            hämta alla rum_id som ej ej har träffar där.
        -> ta upp lista ur "join" från rum och rum_typ där rum id är från förra steget.
        -> skapa ny lista utifrån "join" med den rumtypen man söker och de rum som uppfyller kraven.
        -- SELECT pseudo.start_ledigt, pseudo.slut_ledigt ,r.rum_id, r.rum_typ_id //med nested query där pseudo är derived.
        -- 237-239 datatyp som heter Interval som håller DATETIME eller YEARMONTH. Ev. fixa en sådan med DATETIME eller deriva en sådan?
        *** SQL QUERY:::
        SELECT r.rum_id, r.rum_typ_id
        FROM rum r 
        LEFT JOIN bokning b ON rum_id = rum_id
        WHERE (
            r.rum_typ = "X" 
            AND (b.rum_id IS NULL -- för då finns det ingen bokning, dvs rummet är tillgänligt.
            OR b.incheckning >= "kundens utcheckningsdatum" -- enbart en person kan checka in per dag på ett rum => <
            OR b.utcheckning <= "kundens inchecknignsdatum")
        );

        *** SQL QUERY:::
        -- Usecase vill söka efter lediga enkelrum rum perioden 2024-11-01 - 2024-11-07
        SELECT r.rum_id, r.rum_typ_id 
            FROM rum r
            LEFT JOIN bokning b
                ON (b.rum_id = r.rum_id AND 
                    NOT ( 
                        (b.incheckning < '2024-11-01' AND b.utcheckning < '2024-11-01') 
                        OR
                        (b.incheckning > '2024-11-07' AND b.utcheckning > '2024-11-07') 
                        )
                    ) 
                WHERE b.rum_id IS NULL AND r.rum_typ_id = 'Enkelrum'; 


    Boka rum  <<<<
        ***Går vidare från förra steget ovan***
        gå in bokning med valt rum_id från förra steget, updatera/insert bokning. 
            updatera/insert kund´
            updatera/insert huvud_gäst
            updatera/insert faktura
                *** tänk på ordningen av operationer här: vilken tabell i vilken ordning? "Insert order per build1.txt"
        *** SQL QUERY::: (Usecase boka ett enkelrum för en person perioden 2024-11-01 - 2024-11-07)
        INSERT INTO bokning (rum_id, kund_id, huvud_gast_id, personal_id, rum_pris_id, faktura_id, bokning_datum, antal_gaster, incheckning, utcheckning) 
        VALUES (x, x, x, x, x, x, NOW(), x, '2024-11-01', '2024-11-07');


    Boka rum för grupp <<<<
        göra fina ritningen. 


    [D]Boka middag för grupp
        *** relativt enkel *** 
        gå via gruppbokning till middag, lägg in nytt objekt i middag och uppdatera fältet för foreign key till den gruppbokningen det gäller.
        ** EXAMPLE QUERY:
        INSERT INTO middag (grupp_bokning_id, antal_personer, datum) VALUES (1, 8, '2025-01-20 18:00:00');
    
    
    [D] Se aktuella priser 
        Kolla pris för visst typ av rum. 
        ** motivera i rapport varför vi visar rumpris och erbjudande separat
        --> Ta fram aktuellt pris för rummet
        *** SQL QUERY::: 
        -- Usecase kund vill veta aktuellt pris för enkelrum 
        SELECT pris_per_natt, `start`, slut FROM rum_pris
        WHERE rum_typ_id = "enkelrum" AND `start` < now() AND slut > now(); 

    [D] Se aktuella erbjudanden
        Får en lista med erbjudanden som är aktuella
        *** SQL QUERY::: 
        SELECT * FROM erbjudande
        WHERE `start` < now() AND slut > now(); 

    [D]Se pris / erbjudande som gällde när bokningen gjordes; som gäller för fakturan. detta är för debiteringen i slutet.
        Gå via bokning till faktura -> Kolla om det finns erbjudande i faktura
        Kontrollera bokningsdatum
        vi vill kunna ta upp ett pris och erbjudande för en viss bokning. 

            Söka i rum_pris efter det pris för rumtypen som var aktuellt när bokningen gjordes, derived value som utgår ifrån:
                -> rum_pris.start -> rum_pris.slut 
            ** På samma sätt som vi söker efter ledigt rum
            *** SQL QUERY::: 
            SELECT rp.pris_per_natt, e.prisavdrag, e.villkor, b.bokning_id, f.faktura_id, f.personal_id
	        FROM bokning b
	        INNER JOIN faktura f ON b.faktura_id = f.faktura_id
	        INNER JOIN rum_pris rp ON b.rum_pris_id = rp.rum_pris_id
            LEFT JOIN erbjudande e ON f.erbjudande_id = e.erbjudande_id
	        WHERE bokning_id = 2;  

    [D-F]Checka in (huvud)gäster
        ** Kan ske både med gästens namn / telefonnummer och med boknings-id
        Söka fram rummet som hör till bokningen 
            -> Kontrollera att rummet är utcheckat
            -> Uppdatera checked_in till TRUE  (och checked_out till FALSE) 
        -- FIXME: SAKNAS TESTDATA FÖR DENNA! Finns inga bokningar med incheckning idag (problem noterat 2024-10-16)
        -- WHERE CLAUSE NEEDS: AND r.status = "pending"
                    UPDATE rum r
                    INNER JOIN bokning b ON r.rum_id = b.rum_id
                    INNER JOIN huvud_gast hg ON hg.huvud_gast_id = b.huvud_gast_id
                    SET r.status = "checkat_in"
                    WHERE r.status = "checkat_ut" AND hg.fornamn = "X" AND hg.efternamn = "Y" AND b.incheckning = CURDATE();

                    FÖR TEST:::
                    SELECT * FROM rum
                    INNER JOIN bokning b ON r.rum_id = b.rum_id
                    INNER JOIN huvud_gast hg ON hg.huvud_gast_id = b.huvud_gast_id
                    WHERE r.status = "checkat_ut" AND hg.fornamn = "X" AND hg.efternamn = "Y" AND b.incheckning = CURDATE();


    [D-F]Checka ut (huvud)gäster
        ** Kan ske både med gästens namn / telefonnummer och med boknings-id
        Söka fram rummet som hör till bokningen 
            -> Kontrollera att rummet är incheckat
            -> Uppdatera checked_in till FALSE  (och checked_out till TRUE) 
            -- FIXME: SAKNAS TESTDATA FÖR DENNA!
            UPDATE rum r
                    INNER JOIN bokning b ON r.rum_id = b.rum_id
                    INNER JOIN huvud_gast hg ON hg.huvud_gast_id = b.huvud_gast_id
                    SET r.status = "checkat_ut"
                    WHERE r.status = "checkat_in" AND hg.fornamn = "X" AND hg.efternamn = "Y" AND b.utcheckning <= CURDATE();

    [D]Se om gäst checkat in -- BEHÖVER MOTIVERA I RAPPORT ATT VI TOLKAR DETTA SOM ATT SE STATUS PÅ RUM FÖR EN GÄST.
        Gå från huvud_gast -> bokning -> rum
            - Sök upp huvud_gast_id från gästens namn
            - Hitta bokning-ID som har den huvudgästen
            - Sortera ut den bokningen som gäller just nu
            - Gå till rum som är kopplat till bokningen
            - Kontrollera status på rummet
            SELECT hg.fornamn, hg.efternamn, r.status, b.incheckning, b.utcheckning
            FROM huvud_gast hg
            INNER JOIN bokning b ON hg.huvud_gast_id = b.huvud_gast_id
            INNER JOIN rum r ON b.rum_id = r.rum_id
            WHERE b.incheckning <= CURDATE() AND b.utcheckning >= CURDATE() -- testdata behövs för nutid och dåtid, inte bara framtid >.<
            AND hg.fornamn = "Carina" AND hg.efternamn = "Lindelöf"
            -- AND r.status = "checkat_ut" -- kom ihåg till rapporten att motivera varför detta inte är med!
    [D]Se om gäst checkat ut
        Gå från huvud_gast -> bokning -> rum
            SE OVAN!!


    [D]Se vem i personalen som gjort bokning 
        Selectsats med sökning i bokning samt personal
        *** SQL QUERY:::
            SELECT personal.fornamn, personal.efternamn, bokning.bokning_id, personal.personal_id
            FROM personal
            INNER JOIN bokning ON personal.personal_id = bokning.personal_id;

    
    [D] Ändra datum i bokningar
        Updatesats i bokning.incheck och/eller bokning.utcheck
        *** SQL QUERY:::
            UPDATE bokning SET incheckning = '2024-12-01', utcheckning = '2024-12-15'
            WHERE bokning_id = 1;
    Skriva ut räkning för bokningar / gruppbokningar
        Räkna ut totalpris per kund för specifik bokning / gruppbokning
        Betalnings-spec/kvitto?

Städare:
    [D] Se vilka rum som är utcheckade
        Relativt enkel select-sats
        *** SQL QUERY:::
        SELECT rum_id, `status`, rum_typ_id  FROM rum 
        WHERE `status` = 'checkat_ut';

Från handledare.
SELECT, UPDATE OCH INSERT SKA VARA MED.
minst tre av SQL satserna ska göra en sökning i flera tabeller, 
visa på både JOIN och NESTAD
använd minst en funktion t.ex. count eller group by.